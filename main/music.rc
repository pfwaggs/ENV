#split# music.rc/cdsizer a1f2cf99433afb03a349ef636bdfb17e
#help: cdsizer : shows the size of a possible cd
#help: usage : cdsizer file
function cdsizer () { 
    awk -F: '{sum+=$1}END{print NR":"sum}' $1
}
#split# music.rc/m3ucsv 7b42deedafaa25319b1a3af699de9875
#help: m3ucsv : converts a m3u file to a csv format
#help: usage : m3ucsv file
#help: : n.b. this takes a file and writes output to stdout
#help: : also, note that it will create a temporary file if the 
#help: : input file is dos (crlf) format. the temporary files is
#help: : removed at the end.
function m3ucsv () {
    declare secs size dir
    echo 'Time|Size|Path'
    while read; do
        [[ $REPLY = '#EXTM3U' ]] && continue
        if [[ $REPLY =~ '#EXTINF' ]]; then
            secs=${REPLY#*:}
            secs=${secs%%,*}
            continue
        fi
        size=$(stat --printf='%s' "$REPLY")
        echo "$secs|$size|$REPLY"
    done < $1
}
#split# music.rc/m3uredo 58452190e7fadddb161bf44fe885bb53
#help: m3uredo : redo the cds for given inputs
#help: usage : m3uredo d#### [d#### ...]
function m3uredo () {
    declare x path disk type track
    for x in $*; do
        while read; do
            IFS=$';'
            read disk track path < <(echo "$REPLY")
            IFS=$' \t\n'
            type=${REPLY##*.}
            [[ -d $disk ]] || mkdir $disk
            cp -H "$path" $disk/$disk$track.$type
        done < <(grep $x pairs.csv);
    done
}
#split# music.rc/m3urndm 169c6ca8343046b7cde10c7fc3fbb5e6
#help: m3urndm : randomizes an m3u file
#help: usage : m3urndm 
#help: : this requires you to have already split the m3u into a dir
#help: : and run the script from inside that dir
function m3urndm () {
    declare x y dest=tmp
    [[ -d $dest ]] && { echo $dest exists; return 1; } || mkdir $dest
    ln xx000 $dest
    for x in $(ls -I[^xX]* -Ixx000); do
        echo $RANDOM $x
    done | sort -n |
        awk -v d=$dest '{print d"/"$2}' | paste <(ls -I[^xX]* -Ixx000) - | xargs -L 1 ln 
    cat $dest/* > rndm.m3u
    rm -r $dest
}
#split# music.rc/m3usplitter 0c5a9920f8a7177817181c2e48565bb6
#help: m3usplitter : splits an m3u file into pieces to burn to cd
#help: usage : m3usplitter file.m3u
function m3usplitter () {
    sum=0
    max=$((700*10**6))
    sed -n '/#/!p' $1 |
    while read; do
        s=$(stat -L -c "%s" "$REPLY")
        ((sum+=$s))
        [[ $sum -lt $max ]] || { echo ''; sum=$s; }
        echo "$REPLY"
    done | csplit - /^$/ {*}
}
#split# music.rc/matcher 3ea06481f9cfd580f685b450d6e80677
#help: matcher : finds matching titles
#help: usage : matcher file
#help: :
function matcher () {
    declare name n str master text
    declare -a files
    rm /tmp/*.titles
    grep '^/home/' $1 | sed -nr 's|(.*/[0-9]+ - )(.*)|\2|;s/.mp3$//p' |
        sort | uniq -c |
        while read n text; do
            [[ -n ${files[$n]} ]] || printf -v files[$n] "/tmp/%02d.titles" $n
            echo $text >> ${files[$n]}
        done
}
#split# music.rc/mlinker 9e289ff726054928c89f87bb2cdd815f
#help: mlinker : mlinker creates the links for music dirs
#help: usage : mlinker (mp3|flac) localParent file
#help: : file needs to be the base paths you want mounted. the mount point is
#help: : given on the command line
function mlinker () {
    declare orig remote=${1/#\/} local=${2/%\/}
    while read; do
        echo $REPLY
        need=$(echo $REPLY | cut -f2 -d/)
        [[ -d $local/$need ]] || mkdir "$local/$need"
        ln -s "/$remote/$REPLY" "$local/${REPLY#*/}"
    done < <(cat $3)
}
#split# music.rc/mp3dedupe b3ac84d768cf14776b7213926e74eef4
#help: mp3dedupe : takes a list of mp3 files and creates a uniq list of titles
#help: usage : mp3dedupe file
#help: :
function mp3dedupe () {
    declare x old input=$1
    rm /tmp/??.titles
    awk -F/ '{print $NF}' $input | cut -c6- | sort | uniq -c |
        while read n title; do
            printf -v dest "/tmp/%02d.titles" $n
            echo "$title" >> $dest
        done
    rm /tmp/masterMP3.txt &>/dev/null
    for x in /tmp/*.titles; do
        echo cleaning $x >&2
        while read; do
            grep -m 1 -F "$REPLY" $input
        done < $x >> /tmp/masterMP3.txt
    done
}
#split# music.rc/repath 5894271c532d1005466a54be932f5136
#help: repath : repath rewrites the path in m3u files to be absolute
#help: usage : repath file
#help: : the output file has -real added to basename
#help: : n.b. the input file should be a regular unix file. you may need to
#help: : use dos2unix to convert the m3u file first
function repath () {
    declare dir title input=$1 output=${1/.m3u}-real.m3u
    while read; do
        [[ $REPLY =~ ^# ]] && echo "$REPLY" && continue
        dir=$(realpath "${REPLY%/*}")
        title=${REPLY##*/}
        echo "$dir/$title"
    done < $input > $output
}
#split# music.rc/trknamer 67c0b87fc681e693cf3558b70274c85d
#help: trknamer : used to name the tracks in a simple fashion
#help: usage : trknamer start
function trknamer () {
    declare type track tcount dir dcount
    declare dbfile=pairs.csv
    if [[ -f $dbfile ]]; then
        dcount=$(sed -n '2,$p' $dbfile | cut -f1 -d\; | sort -r | sed -n '1p')
        dcount=$((1+10#${dcount/d}))
    else
        dcount=1
    fi
    for x in xx*; do
        printf -v dir "d%04d" $((dcount++))
        [[ -d $dir ]] || mkdir $dir
        tcount=1
        while read; do
            [[ -n $REPLY ]] || continue
            type=${REPLY##*.}
            printf -v track "%s%03d" ${type:0:1} $((tcount++))
            cp -H "$REPLY" $dir/$dir$track.$type && echo "$dir;$track;$REPLY"
        done < <(cut -f2 -d: $x) >> pairs
        awk -v n=$x -F: '{sum+=$1}END{print n":"NR":"sum}' $x
    done
}
