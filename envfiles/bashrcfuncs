
# some basic list operations
# -s sort
# -e exists
# -r reverse
# -l resolve links
# -c clear items
# -u unique items
# -S output a single string
function _FixList ()
{
    declare p opt
    declare -a nlist list opts
    for p in "$@"; do
        [[ $p =~ ^-.* ]] && opts+=($p) || list+=("$p")
    done
    if [[ ${#list[@]} -eq 0 ]]; then
        while read p; do
            list+=("$p")
        done < <(cat -- -)
    fi
    for opt in ${opts[@]}; do
        nlist=()
        case $opt in
            -s)
		while read -r p; do
                    nlist+=("$p")
                done < <(printf '%s\n' "${list[@]}" | sort)
                ;;
            -e)
                for p in "${list[@]}"; do
                    [[ -e "$p" ]] && nlist+=("$p") || continue
                done
                ;;
            -r)
		while read -r p; do
                    nlist+=("$p")
                done < <(printf '%s\n' "${list[@]}" | tac)
                ;;
            -l)
                for p in "${list[@]}"; do
                    [[ -L "$p" ]] && p=$(readlink -e "$p") || :
                    nlist+=("$p")
                done
                ;;
            -c)
		for p in "${list[@]:1}"; do
		    [[ $p =~ ${list[0]}.* ]] || nlist+=("$p")
                done
                ;;
            -u)
                for p in "${list[@]}"; do
                    [[ ${nlist[@]} =~ :$p ]] || nlist+=(":$p")
                done
                nlist=("${nlist[@]/#:}")
                ;;
            -S|*)
                declare IFS=${SEP:-:}$IFS
                echo "${list[*]}"
		return
                ;;
        esac
        list=("${nlist[@]}")
    done
    printf '%s\n' "${list[@]}"
}

# clear the environment of crap
function envpurge ()
{
    complete -r
    unalias -a
    unset -f $(compgen -A function) &>/dev/null
}
declare -fr envpurge

# produces a list of paths for source-ing input paths should specify a
# directory or filename of a list of files in the parent directory to
# load relative to it's parent
function envfxp ()
{
    declare arg
    declare -a list
    for arg in $@; do
	if [[ -f $arg ]]; then
            dir=${arg%/*};
            for line in $(grep -o -P '^\w+' $arg); do
		list+=($dir/$line);
            done;
	else
	    for line in ${arg}/*; do
		list+=($line)
	    done
	fi
    done
    echo "${list[@]}"
}
declare -frx envfxp

# sources a provided list of files
function load ()
{
    declare x
    [[ $# -gt 0 ]] || envpurge
    for x in $(mname $@); do
        [[ -f $x ]] && . $x || continue
        [[ -f ~/.quiet ]] && echo -n . || echo $x
    done
    echo ' done'
}
declare -fr load

# returns the basename of given paths
function bname ()
{
    declare x
    for x in $@; do echo ${x##*/}; done
}

# returns the dirname of given paths and variable expansions
function dname ()
{
    declare x
    declare -a files list
    for x in $@; do
        [[ $x =~ / ]] && list+=($x) || files+=($x)
    done
    for x in ${files[@]}; do
        X=${x^^}
        for y in ${!x} $X ${!X}; do
            [[ $y =~ / ]] && { list+=(${y//:/ }); break; }
        done
    done
    for x in ${list[@]}; do
        [[ -d $x ]] && echo $x || echo ${x%/*}
    done
}

# merges names and dirs into a set. names are checked against parents to
# ENVFILES and parents of given dirs. nil input returns files to be sourced
# when the shell was started.
function mname ()
{ 
    declare x name dir path
    declare -a names list tmp dirs
    for path in ${ENVFILES//:/ }; do
	[[ -d $path ]] && dirs+=($path) || dirs+=(${path%/*})
    done
    for x in $@; do
        if [[ $x =~ '/' ]]; then
            [[ -f $x ]] && list+=($x) || :
            [[ -d $x ]] && dirs+=($x) || dirs+=(${x%/*})
        else
	    names+=($x)
	fi
    done
    for name in ${names[@]}; do
	for path in $(_FixList -e "${dirs[@]/%//$name}"); do
	    list+=("$path")
	done;
    done;
    [[ ${#list[@]} -gt 0 ]] || list=($(envfxp ${ENVFILES//:/ }))
    _FixList -u ${list[@]}
}
